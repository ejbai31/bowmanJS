{"version":3,"sources":["webpack:///webpack/bootstrap fbb98e6739ddd4dddf5b","webpack:///./library/bowman.js","webpack:///./library/utils.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7D0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC3SA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA,E","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fbb98e6739ddd4dddf5b","import { distance, angle } from './utils';\n\nvar arrows = [];\nvar speedDiv = 4;\nvar gameOver = false;\nvar score = 0;\nvar arrowCount = 3;\nvar addArrow = function () {\n  arrows.unshift(new Arrow());\n  currentArrow = arrows[0];\n};\n\nfunction Arrow() {\n  this.x = shootingCirc.x;\n  this.y = shootingCirc.y;\n  this.arrowTipCoords = {\n    x: this.x + 25,\n    y: this.y\n  };\n\n  this.leftTipCoords = {\n    x: this.x + 17,\n    y: this.y - 3\n  };\n  this.rightTipCoords = {\n    x: this.x + 17,\n    y: this.y + 3\n  };\n  this.velX = 0;\n  this.velY = 0;\n  this.velocity = 0;\n  this.firing = false;\n}\n\nArrow.prototype.fireArrow = function () {\n  if (mousePos && !this.firing) {\n    this.velocity = Math.min(shootingCirc.r, distance(shootingCirc, mousePos)) / speedDiv;\n    this.velX = Math.cos(angle(mousePos, shootingCirc)) * this.velocity;\n    this.velY = Math.sin(angle(mousePos, shootingCirc)) * this.velocity;\n    this.firing = true;\n    attempts();\n    addArrow();\n    console.log(arrowCount);\n    document.getElementById(\"shots-left\").innerHTML = arrowCount;\n  }\n};\n\nArrow.prototype.calcTrajectory = function () {\n  if (this.y <= groundPoint && (this.x <= target.x - 30 && this.y <= target.y + 20) && this.firing) {\n    this.velY += gravity;\n    this.x += this.velX;\n    this.y += this.velY;\n  } else {\n    this.velX = 0;\n    this.velY = 0;\n    this.firing = false;\n  }\n};\n\nArrow.prototype.calcArrowHead = function () {\n  if (this.firing) {\n    var headAngle = Math.atan2(this.velX, this.velY);\n  } else if (mousePos && this == currentArrow) {\n    var headAngle = Math.PI / 2 - angle(mousePos, shootingCirc);\n  } else return;\n\n  this.arrowTipCoords.x = this.x + 30 * Math.sin(headAngle);\n  this.arrowTipCoords.y = this.y + 30 * Math.cos(headAngle);\n  var arrowTip = { x: this.arrowTipCoords.x, y: this.arrowTipCoords.y };\n\n  this.leftTipCoords.x = arrowTip.x - 3 * Math.sin(headAngle - Math.PI / 4);\n  this.leftTipCoords.y = arrowTip.y - 3 * Math.cos(headAngle - Math.PI / 4);\n  this.rightTipCoords.x = arrowTip.x - 3 * Math.sin(headAngle + Math.PI / 4);\n  this.rightTipCoords.y = arrowTip.y - 3 * Math.cos(headAngle + Math.PI / 4);\n\n  // console.log(this.arrowTipCoords.x, this.arrowTipCoords.y);\n};\n\nArrow.prototype.drawArrow = function () {\n  this.calcTrajectory();\n  this.calcArrowHead();\n  var arrowTip = this.arrowTipCoords;\n  var leftTip = this.leftTipCoords;\n  var rightTip = this.rightTipCoords;\n\n  ctx.beginPath();\n  ctx.moveTo(this.x, this.y);\n  ctx.lineTo(arrowTip.x, arrowTip.y);\n\n  ctx.moveTo(arrowTip.x, arrowTip.y);\n  ctx.lineTo(leftTip.x, leftTip.y);\n\n  ctx.moveTo(arrowTip.x, arrowTip.y);\n  ctx.lineTo(rightTip.x, rightTip.y);\n\n  ctx.strokeStyle = \"black\";\n  ctx.stroke();\n};\n\nvar canvas = document.createElement(\"canvas\");\ncanvas.id = 'canvas';\nvar ctx = canvas.getContext(\"2d\");\ncanvas.width = window.innerWidth - 15;\ncanvas.height = window.innerHeight - 15;\ndocument.body.appendChild(canvas);\nlet cWidth = canvas.width;\nlet cHeight = canvas.height;\n\nvar gravity = 0.4;\nvar groundPoint = cHeight - (cHeight / 4);\n\nvar drawnBack = false;\nvar firedArrow = false;\n\nvar isInLimit = function (mousePos) {\n  var distFromCenter = distance(drawBackCirc, mousePos);\n  if (distFromCenter < drawBackCirc.r) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nfunction getMousePos(canvas, e) {\n  var rect = canvas.getBoundingClientRect();\n  return {\n    x: e.clientX - rect.left,\n    y: e.clientY - rect.top\n  };\n}\n\n\nvar mousePos;\nvar mouseDown = false;\nvar mouseUp = false;\n\naddEventListener(\"mousemove\", function (e) {\n  mousePos = getMousePos(canvas, e);\n}, false);\n\naddEventListener(\"mousedown\", function (e) {\n  mousePos = getMousePos(canvas, e);\n  mouseDown = true;\n  mouseUp = false;\n}, false);\n\naddEventListener(\"mouseup\", function (e) {\n  mousePos = getMousePos(canvas, e);\n  mouseUp = true;\n  mouseDown = false;\n}, false);\n\nvar drawScene = function () {\n  var ground = groundPoint + 15;\n  ctx.beginPath();\n  ctx.moveTo(0, ground);\n  ctx.lineTo(cWidth, ground);\n  ctx.strokeStyle = \"rgba(0,100,50,0.6)\";\n  ctx.stroke();\n  ctx.fillStyle = \"rgba(0,200,100,1)\";\n  ctx.fillRect(0, ground, cWidth, cHeight);\n};\n\n\nvar getAimCoords = function (mousePos) {\n  var aimAng = Math.PI / 2 - angle(mousePos, shootingCirc);\n  var aimDistance = Math.min(distance(shootingCirc, mousePos), shootingCirc.r);\n  var x = shootingCirc.x + -aimDistance * Math.sin(aimAng);\n  var y = shootingCirc.y + -aimDistance * Math.cos(aimAng);\n  return { x: x, y: y };\n};\n\nvar drawAimer = function () {\n  if (drawnBack) {\n    var aimCoords = getAimCoords(mousePos);\n    ctx.beginPath();\n    ctx.moveTo(aimCoords.x, aimCoords.y);\n    ctx.lineTo(shootingCirc.x, shootingCirc.y);\n    ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n    ctx.stroke();\n  }\n};\nvar shootingCirc = {\n  x: 200,\n  y: groundPoint - 150,\n  r: 100\n};\n\nvar drawBackCirc = {\n  x: shootingCirc.x,\n  y: shootingCirc.y,\n  r: 25\n};\n\nvar drawCircles = function () {\n  ctx.strokeStyle = \"rgba(0,0,0,0.5)\";\n  ctx.beginPath();\n  ctx.arc(drawBackCirc.x, drawBackCirc.y, drawBackCirc.r, 0, 2 * Math.PI);\n  ctx.lineWidth = 10;\n  ctx.stroke();\n  drawAimer();\n};\n\nvar target = {\n  x: cWidth * (0.95),\n  y: groundPoint - 20\n};\n\nvar drawTarget = function () {\n  ctx.setLineDash([]);\n  ctx.beginPath();\n  ctx.ellipse(target.x, target.y - 40, 50, 75, 0, 0, 2 * Math.PI);\n  ctx.stroke();\n  ctx.beginPath();\n  ctx.fillStyle = \"red\";\n  ctx.ellipse(target.x, target.y - 40, 25, 37.5, 0, 0, 2 * Math.PI);\n  ctx.stroke();\n};\n\nvar isFiredArrow = function () {\n  if (mousePos && drawnBack && mouseUp) {\n    drawnBack = false;\n    firedArrow = true;\n  }\n};\n\nvar isDrawnBack = function () {\n  if (mousePos && isInLimit(mousePos)) {\n    if (mouseDown) drawnBack = true;\n    else if (mouseUp) drawnBack = false;\n  }\n};\n\nvar writeInfo = function (mousePos) {\n  ctx.textAlign = \"left\";\n  ctx.textBaseline = \"top\";\n  ctx.fillStyle = \"black\";\n  \n  ctx.fillText(\"Mouse Position: \" + mousePos.x + \", \" + mousePos.y, 20, 20);\n  ctx.fillText(\"Circle Position: \" + shootingCirc.x + \", \" + shootingCirc.y, 20, 40);\n  ctx.fillText(\"Angle: \" + angle(mousePos, shootingCirc), 20, 60);\n};\n\nvar attempts = function() {\n  if(arrows.length > 0){\n    \n    arrowCount = arrowCount - 1;\n    document.getElementById(\"shots-left\").innerHTML = arrowCount;\n  }\n  if(arrows.length >= 3){\n    // console.log(\"hi\");\n    gameOver();\n  }\n};\n\n// var score = function(){\n//   if()\n// };\n\nvar update = function () {\n  isDrawnBack();\n  isFiredArrow();\n  if (firedArrow) {\n    currentArrow.fireArrow();\n    firedArrow = false;\n  }\n\n  ctx.clearRect(0, 0, cWidth, cHeight);\n};\n\nvar render = function () {\n  if (mousePos) writeInfo(mousePos);\n  drawCircles();\n  drawTarget();\n  for (let i = 0; i < arrows.length; i++) {\n    arrows[i].drawArrow();\n  }\n  drawScene();\n};\n\n\nvar main = function () {\n  update();\n  render();\n  requestAnimationFrame(main);\n};\n\nvar reset = function (){\n  gameOver = false;\n};\n\nvar gameOver = function (){\n  document.getElementById(\"game-over\").classList.remove(\"hide\");\n};\n\nvar w = window;\nrequestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;\naddArrow();\nvar currentArrow = arrows[0];\nmain();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./library/bowman.js\n// module id = 0\n// module chunks = 0","export const distance = (p1, p2) => {\n  return Math.sqrt(Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2));\n};\n\nexport const angle = (p1, p2) => {\n  return Math.atan2(p2.y - p1.y, p2.x - p1.x);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./library/utils.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}